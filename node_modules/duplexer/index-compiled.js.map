{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["var Stream = require(\"stream\")\nvar writeMethods = [\"write\", \"end\", \"destroy\"]\nvar readMethods = [\"resume\", \"pause\"]\nvar readEvents = [\"data\", \"close\"]\nvar slice = Array.prototype.slice\n\nmodule.exports = duplex\n\nfunction forEach (arr, fn) {\n    if (arr.forEach) {\n        return arr.forEach(fn)\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n        fn(arr[i], i)\n    }\n}\n\nfunction duplex(writer, reader) {\n    var stream = new Stream()\n    var ended = false\n\n    forEach(writeMethods, proxyWriter)\n\n    forEach(readMethods, proxyReader)\n\n    forEach(readEvents, proxyStream)\n\n    reader.on(\"end\", handleEnd)\n\n    writer.on(\"drain\", function() {\n      stream.emit(\"drain\")\n    })\n\n    writer.on(\"error\", reemit)\n    reader.on(\"error\", reemit)\n\n    stream.writable = writer.writable\n    stream.readable = reader.readable\n\n    return stream\n\n    function proxyWriter(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            return writer[methodName].apply(writer, arguments)\n        }\n    }\n\n    function proxyReader(methodName) {\n        stream[methodName] = method\n\n        function method() {\n            stream.emit(methodName)\n            var func = reader[methodName]\n            if (func) {\n                return func.apply(reader, arguments)\n            }\n            reader.emit(methodName)\n        }\n    }\n\n    function proxyStream(methodName) {\n        reader.on(methodName, reemit)\n\n        function reemit() {\n            var args = slice.call(arguments)\n            args.unshift(methodName)\n            stream.emit.apply(stream, args)\n        }\n    }\n\n    function handleEnd() {\n        if (ended) {\n            return\n        }\n        ended = true\n        var args = slice.call(arguments)\n        args.unshift(\"end\")\n        stream.emit.apply(stream, args)\n    }\n\n    function reemit(err) {\n        stream.emit(\"error\", err)\n    }\n}\n"]}