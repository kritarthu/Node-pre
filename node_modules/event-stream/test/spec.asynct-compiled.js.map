{"version":3,"sources":["spec.asynct.js"],"names":[],"mappings":";;;;;;;;;;AAQA,IAAI,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;AACtB,IAAI,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAA;AACzC,IAAI,IAAI,GAAG,OAAO,CAAC,aAAa,CAAC,CAAA;;AAEjC,OAAO,CAAC,eAAe,CAAC,GAAG,UAAU,IAAI,EAAE;;AAEzC,MAAI,MAAM,GAAG,EAAE,CAAC,OAAO,EAAE,CAAA;AACzB,MAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,CAAA;;AAEvC,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;AACf,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;AACf,QAAM,CAAC,KAAK,EAAE,CAAA;AACd,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;AACf,QAAM,CAAC,MAAM,EAAE,CAAA;AACf,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;AACf,QAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;;AAEb,SAAO,CAAC,QAAQ,CAAC,YAAW;AAC1B,KAAC,CAAC,QAAQ,EAAE,CAAA;AACZ,QAAI,CAAC,IAAI,EAAE,CAAA;GACZ,CAAC,CAAA;CACH,CAAA;;AAED,OAAO,CAAC,+BAA+B,CAAC,GAAG,UAAU,IAAI,EAAE;;AAEzD,MAAI,MAAM,GAAG,EAAE,CAAC,OAAO,EAAE,CAAA;AACzB,MAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,CAAA;;AAEvC,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;AACf,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;AACf,QAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAA;AACb,QAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;;AAEf,SAAO,CAAC,QAAQ,CAAC,YAAY;AAC3B,KAAC,CAAC,QAAQ,EAAE,CAAA;AACZ,QAAI,CAAC,IAAI,EAAE,CAAA;GACZ,CAAC,CAAA;CAEH,CAAA;;AAED,OAAO,CAAC,UAAU,CAAC,GAAG,UAAU,IAAI,EAAE;;AAEpC,MAAI,MAAM,GAAG,EAAE,CAAC,OAAO,EAAE,CAAA;AACzB,MAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC,QAAQ,EAAE,CAAA;;AAEvC,QAAM,CAAC,GAAG,EAAE,CAAA;;AAEZ,SAAO,CAAC,QAAQ,CAAC,YAAY;AAC3B,KAAC,CAAC,QAAQ,EAAE,CAAA;AACZ,QAAI,CAAC,IAAI,EAAE,CAAA;GACZ,CAAC,CAAA;CAEH,CAAA;;;;;;;;;;;;;;;;;;;;;;;AAyBD,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAA","file":"spec.asynct-compiled.js","sourcesContent":["/*\n  assert that data is called many times\n  assert that end is called eventually\n\n  assert that when stream enters pause state,\n  on drain is emitted eventually.\n*/\n\nvar es = require('..')\nvar it = require('it-is').style('colour')\nvar spec = require('stream-spec')\n\nexports['simple stream'] = function (test) {\n\n  var stream = es.through()\n  var x = spec(stream).basic().pausable()\n\n  stream.write(1)\n  stream.write(1)\n  stream.pause()\n  stream.write(1)\n  stream.resume()\n  stream.write(1)\n  stream.end(2) //this will call write()\n\n  process.nextTick(function (){\n    x.validate()\n    test.done()\n  }) \n}\n\nexports['throw on write when !writable'] = function (test) {\n\n  var stream = es.through()\n  var x = spec(stream).basic().pausable()\n\n  stream.write(1)\n  stream.write(1)\n  stream.end(2) //this will call write()\n  stream.write(1) //this will be throwing..., but the spec will catch it.\n\n  process.nextTick(function () {\n    x.validate()\n    test.done()\n  })\n  \n}\n\nexports['end fast'] = function (test) {\n\n  var stream = es.through()\n  var x = spec(stream).basic().pausable()\n\n  stream.end() //this will call write()\n\n  process.nextTick(function () {\n    x.validate()\n    test.done()\n  })\n  \n}\n\n\n/*\n  okay, that was easy enough, whats next?\n\n  say, after you call paused(), write should return false\n  until resume is called.\n\n  simple way to implement this:\n    write must return !paused\n  after pause() paused = true\n  after resume() paused = false\n\n  on resume, if !paused drain is emitted again.\n  after drain, !paused\n\n  there are lots of subtle ordering bugs in streams.\n\n  example, set !paused before emitting drain.\n\n  the stream api is stateful. \n*/\n\n\nrequire('./helper')(module)\n"]}