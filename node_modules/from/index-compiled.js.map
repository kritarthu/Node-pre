{"version":3,"sources":["index.js"],"names":[],"mappings":";AACA,YAAY,CAAC;;AAEb,IAAI,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAA;;;;;;;;AAQ9B,MAAM,CAAC,OAAO,GACd,SAAS,IAAI;;;4BAAU;QAAR,MAAM;AAWf,KAAC,GAAiB,CAAC;;QAWd,IAAI,GAAb,SAAS,IAAI,GAAI;AACf,OAAC,CAAC,OAAO,GAAG,IAAI,CAAA;AAChB,UAAG,CAAC,CAAC,KAAK,EAAE,OAAM;AAClB,aAAM,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,YAAY;AAC7D,YAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,EACpB,IAAI,EAAE,CAAA;OACX,CAAC,EACC;KACJ;;;;AA7BD,QAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;AACxB,YAAM,GAAG,MAAM,CAAC,KAAK,EAAE,CAAA;;WACV,UAAU,CAAC,EAAE;AACxB,YAAG,MAAM,CAAC,MAAM,EACd,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,CAAA,KAEjC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAClB,eAAO,IAAI,CAAA;OACZ;;;;KACF;AACD,QAAI,CAAC,GAAG,IAAI,MAAM,EAAE;QAAE,CAAC,GAAG,CAAC,CAAA;AAC3B,KAAC,CAAC,KAAK,GAAG,KAAK,CAAA;AACf,KAAC,CAAC,OAAO,GAAG,KAAK,CAAA;AACjB,KAAC,CAAC,QAAQ,GAAG,IAAI,CAAA;AACjB,KAAC,CAAC,QAAQ,GAAG,KAAK,CAAA;AAClB,KAAC,CAAC,MAAM,GAAG,KAAK,CAAA;AAChB,KAAC,CAAC,KAAK,GAAG,KAAK,CAAA;AACf,KAAC,CAAC,KAAK,GAAG,YAAY;AACpB,OAAC,CAAC,OAAO,GAAG,IAAI,CAAA;AAChB,OAAC,CAAC,MAAM,GAAG,IAAI,CAAA;KAChB,CAAA;;AAUD,KAAC,CAAC,MAAM,GAAG,YAAY;AACrB,OAAC,CAAC,OAAO,GAAG,IAAI,CAAA;AAChB,OAAC,CAAC,MAAM,GAAG,KAAK,CAAA;AAChB,UAAI,EAAE,CAAA;KACP,CAAA;AACD,KAAC,CAAC,EAAE,CAAC,KAAK,EAAE,YAAY;AACtB,OAAC,CAAC,KAAK,GAAG,IAAI,CAAA;AACd,OAAC,CAAC,QAAQ,GAAG,KAAK,CAAA;AAClB,aAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,CAAA;KAC5B,CAAC,CAAA;AACF,KAAC,CAAC,OAAO,GAAG,YAAY;AACtB,OAAC,CAAC,KAAK,GAAG,IAAI,CAAA;AACd,OAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;KAChB,CAAA;;;;;;;AAOD,WAAO,CAAC,QAAQ,CAAC,YAAY;AAC3B,UAAG,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,MAAM,EAAE,CAAA;KAC1B,CAAC,CAAA;AACF,WAAO,CAAC,CAAA;GACT;CAAA,CAAA","file":"index-compiled.js","sourcesContent":["\n'use strict';\n\nvar Stream = require('stream')\n\n// from\n//\n// a stream that reads from an source.\n// source may be an array, or a function.\n// from handles pause behaviour for you.\n\nmodule.exports =\nfunction from (source) {\n  if(Array.isArray(source)) {\n    source = source.slice()\n    return from (function (i) {\n      if(source.length)\n        this.emit('data', source.shift())\n      else\n        this.emit('end')\n      return true\n    })\n  }\n  var s = new Stream(), i = 0\n  s.ended = false\n  s.started = false\n  s.readable = true\n  s.writable = false\n  s.paused = false\n  s.ended = false\n  s.pause = function () {\n    s.started = true\n    s.paused = true\n  }\n  function next () {\n    s.started = true\n    if(s.ended) return\n    while(!s.ended && !s.paused && source.call(s, i++, function () {\n      if(!s.ended && !s.paused)\n          next()\n    }))\n      ;\n  }\n  s.resume = function () {\n    s.started = true\n    s.paused = false\n    next()\n  }\n  s.on('end', function () {\n    s.ended = true\n    s.readable = false\n    process.nextTick(s.destroy)\n  })\n  s.destroy = function () {\n    s.ended = true\n    s.emit('close') \n  }\n  /*\n    by default, the stream will start emitting at nextTick\n    if you want, you can pause it, after pipeing.\n    you can also resume before next tick, and that will also\n    work.\n  */\n  process.nextTick(function () {\n    if(!s.started) s.resume()\n  })\n  return s\n}\n"]}