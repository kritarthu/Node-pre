{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n\n  var stream = new Stream()\n    , self = this\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n    , lastWritten = 0\n    , inNext = false\n\n  this.opts = opts || {};\n  var errorEventName = this.opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {}\n\n  stream.writable = true\n  stream.readable = true\n\n  function queueData (data, number) {\n    var nextToWrite = lastWritten + 1\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data])\n      }\n      lastWritten ++\n      nextToWrite ++\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite]\n      delete writeQueue[nextToWrite]\n      return queueData(dataToWrite, nextToWrite)\n    }\n\n    outputs ++\n    if(inputs === outputs) {\n      if(paused) paused = false, stream.emit('drain') //written all the incoming events\n      if(ended) end()\n    }\n  }\n\n  function next (err, data, number) {\n    if(destroyed) return\n    inNext = true\n\n    if (!err || self.opts.failures) {\n      queueData(data, number)\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [ errorEventName, err ]);\n    }\n\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper (input, number, callback) {\n    return mapper.call(null, input, function(err, data){\n      callback(err, data, number)\n    })\n  }\n\n  stream.write = function (data) {\n    if(ended) throw new Error('map stream is not writable')\n    inNext = false\n    inputs ++\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined) {\n      return queueData(data, inputs)\n    } else if (inputs == outputs) { //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy() \n    }\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end()\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n\n\n\n\n"]}