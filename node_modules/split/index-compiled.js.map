{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;;AAOA,IAAI,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAA;AAChC,IAAI,OAAO,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC,aAAa,CAAA;;AAErD,MAAM,CAAC,OAAO,GAAG,KAAK,CAAA;;;;AAItB,SAAS,KAAK,CAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE;AACxC,MAAI,OAAO,GAAG,IAAI,OAAO,EAAE,CAAA;AAC3B,MAAI,KAAK,GAAG,EAAE,CAAA;AACd,MAAI,SAAS,GAAG,OAAO,IAAI,OAAO,CAAC,SAAS,CAAC;AAC7C,MAAG,UAAU,KAAK,OAAO,OAAO,EAC9B,MAAM,GAAG,OAAO,EAAE,OAAO,GAAG,IAAI,CAAA;AAClC,MAAI,CAAC,OAAO,EACV,OAAO,GAAG,OAAO,CAAA;;AAEnB,WAAS,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE;AAC3B,QAAG,MAAM,EAAE;AACT,UAAI;AACF,aAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAA;OACtB,CACD,OAAO,GAAG,EAAE;AACV,eAAO,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAA;OACjC;AACD,UAAG,WAAW,KAAK,OAAO,KAAK,EAC7B,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;KACtB,MAEC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;GACtB;;AAED,WAAS,IAAI,CAAE,MAAM,EAAE,MAAM,EAAE;AAC7B,QAAI,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,IAAI,GAAG,KAAK,GAAG,EAAE,CAAA,GAAI,MAAM,CAAA,CAAE,KAAK,CAAC,OAAO,CAAC,CAAA;AACnE,SAAK,GAAG,MAAM,CAAC,GAAG,EAAE,CAAA;;AAEpB,QAAI,SAAS,IAAI,KAAK,CAAC,MAAM,GAAG,SAAS,EACvC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC,CAAA;;AAE3D,SAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AACtC,UAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;AACrB,UAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;KACpB;GACF;;AAED,SAAO,OAAO,CAAC,UAAU,CAAC,EAAE;AAC1B,QAAI,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAA;GAC7B,EACD,YAAY;AACV,QAAG,OAAO,CAAC,GAAG,EACZ,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC,CAAA;AAC3B,QAAG,KAAK,IAAI,IAAI,EACd,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;AACnB,QAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAA;GACjB,CAAC,CAAA;CACH","file":"index-compiled.js","sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar through = require('through')\nvar Decoder = require('string_decoder').StringDecoder\n\nmodule.exports = split\n\n//TODO pass in a function to map across the lines.\n\nfunction split (matcher, mapper, options) {\n  var decoder = new Decoder()\n  var soFar = ''\n  var maxLength = options && options.maxLength;\n  if('function' === typeof matcher)\n    mapper = matcher, matcher = null\n  if (!matcher)\n    matcher = /\\r?\\n/\n\n  function emit(stream, piece) {\n    if(mapper) {\n      try {\n        piece = mapper(piece)\n      }\n      catch (err) {\n        return stream.emit('error', err)\n      }\n      if('undefined' !== typeof piece)\n        stream.queue(piece)\n    }\n    else\n      stream.queue(piece)\n  }\n\n  function next (stream, buffer) {\n    var pieces = ((soFar != null ? soFar : '') + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    if (maxLength && soFar.length > maxLength)\n      stream.emit('error', new Error('maximum buffer reached'))\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i]\n      emit(stream, piece)\n    }\n  }\n\n  return through(function (b) {\n    next(this, decoder.write(b))\n  },\n  function () {\n    if(decoder.end)\n      next(this, decoder.end())\n    if(soFar != null)\n      emit(this, soFar)\n    this.queue(null)\n  })\n}\n\n"]}