{"version":3,"sources":["split.asynct.js"],"names":[],"mappings":"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","file":"split.asynct-compiled.js","sourcesContent":["var es = require('event-stream')\n  , it = require('it-is').style('colour')\n  , d = require('ubelt')\n  , split = require('..')\n  , join = require('path').join\n  , fs = require('fs')\n  , Stream = require('stream').Stream\n  , Readable = require('stream').Readable\n  , spec = require('stream-spec')\n  , through = require('through')\n  , stringStream = require('string-to-stream')\n\nexports ['split() works like String#split'] = function (test) {\n  var readme = join(__filename)\n    , expected = fs.readFileSync(readme, 'utf-8').split('\\n')\n    , cs = split()\n    , actual = []\n    , ended = false\n    , x = spec(cs).through()\n\n  var a = new Stream ()\n\n  a.write = function (l) {\n    actual.push(l.trim())\n  }\n  a.end = function () {\n\n      ended = true\n      expected.forEach(function (v,k) {\n        //String.split will append an empty string ''\n        //if the string ends in a split pattern.\n        //es.split doesn't which was breaking this test.\n        //clearly, appending the empty string is correct.\n        //tests are passing though. which is the current job.\n        if(v)\n          it(actual[k]).like(v)\n      })\n      //give the stream time to close\n      process.nextTick(function () {\n        test.done()\n        x.validate()\n      })\n  }\n  a.writable = true\n\n  fs.createReadStream(readme, {flags: 'r'}).pipe(cs)\n  cs.pipe(a)\n\n}\n\nexports ['split() takes mapper function'] = function (test) {\n  var readme = join(__filename)\n    , expected = fs.readFileSync(readme, 'utf-8').split('\\n')\n    , cs = split(function (line) { return line.toUpperCase() })\n    , actual = []\n    , ended = false\n    , x = spec(cs).through()\n\n  var a = new Stream ()\n\n  a.write = function (l) {\n    actual.push(l.trim())\n  }\n  a.end = function () {\n\n      ended = true\n      expected.forEach(function (v,k) {\n        //String.split will append an empty string ''\n        //if the string ends in a split pattern.\n        //es.split doesn't which was breaking this test.\n        //clearly, appending the empty string is correct.\n        //tests are passing though. which is the current job.\n        if(v)\n          it(actual[k]).equal(v.trim().toUpperCase())\n      })\n      //give the stream time to close\n      process.nextTick(function () {\n        test.done()\n        x.validate()\n      })\n  }\n  a.writable = true\n\n  fs.createReadStream(readme, {flags: 'r'}).pipe(cs)\n  cs.pipe(a)\n\n}\n\nexports ['split() works with empty string chunks'] = function (test) {\n  var str = ' foo'\n    , expected = str.split(/[\\s]*/).reduce(splitBy(/[\\s]*/), [])\n    , cs1 = split(/[\\s]*/)\n    , cs2 = split(/[\\s]*/)\n    , actual = []\n    , ended = false\n    , x = spec(cs1).through()\n    , y = spec(cs2).through()\n\n  var a = new Stream ()\n\n  a.write = function (l) {\n    actual.push(l.trim())\n  }\n  a.end = function () {\n\n      ended = true\n      expected.forEach(function (v,k) {\n        //String.split will append an empty string ''\n        //if the string ends in a split pattern.\n        //es.split doesn't which was breaking this test.\n        //clearly, appending the empty string is correct.\n        //tests are passing though. which is the current job.\n        if(v)\n          it(actual[k]).like(v)\n      })\n      //give the stream time to close\n      process.nextTick(function () {\n        test.done()\n        x.validate()\n        y.validate()\n      })\n  }\n  a.writable = true\n\n  cs1.pipe(cs2)\n  cs2.pipe(a)\n\n  cs1.write(str)\n  cs1.end()\n\n}\n\nfunction splitBy (delimeter) {\n  return function (arr, piece) {\n    return arr.concat(piece.split(delimeter))\n  }\n}"]}