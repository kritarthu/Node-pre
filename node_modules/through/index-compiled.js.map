{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end, opts) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = [], _ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n//  stream.autoPause   = !(opts && opts.autoPause   === false)\n  stream.autoDestroy = !(opts && opts.autoDestroy === false)\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = stream.push = function (data) {\n//    console.error(ended)\n    if(_ended) return stream\n    if(data === null) _ended = true\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable && stream.autoDestroy)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable && stream.autoDestroy)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    return stream\n  }\n\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n      stream.emit('resume')\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n"]}